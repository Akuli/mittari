import re
import json
import copy
import sys
import time
import tkinter
import threading
import subprocess
import random
from functools import partial
from pathlib import Path
from typing import TypedDict, Any, Literal, cast
from tkinter import ttk, messagebox
from math import sin, pi


# The hardware has room for systems that output a quiet signal from headphones
# jack. Exposing it unnecessarily makes the sliders annoyingly sensitive,
# because only a short section in the beginning of the slider is usable.
MAX_GAIN = 0.3


class ChannelConfig(TypedDict):
    calibration: list[float]  # 11 values: 0%, 10%, 20%, ..., 100%
    metric: str  # what does this meter show, e.g. "CPU"


class Config(TypedDict):
    audio_device: str
    sample_rate: int
    frequency: int
    refresh_interval: float
    left: ChannelConfig
    right: ChannelConfig


DEFAULT_CONFIG: Config = {
    "audio_device": "default",
    "sample_rate": 44100,
    "frequency": 1000,
    "refresh_interval": 0.1,
    "left": {
        "calibration": [n/100*MAX_GAIN for n in range(0, 101, 10)],
        "metric": "CPU",
    },
    "right": {
        "calibration": [n/100*MAX_GAIN for n in range(0, 101, 10)],
        "metric": "RAM",
    },
}


def load_config(path: Path) -> Config:
    result: dict[str, Any] = copy.deepcopy(DEFAULT_CONFIG)  # type: ignore

    with path.open(encoding="utf-8") as file:
        current_section = result

        for lineno, line in enumerate(file, start=1):
            line = line.split('#')[0].rstrip()
            if not line:
                continue

            if not line.startswith(' '):
                current_section = result
            line = line.lstrip()

            if re.fullmatch(r"\w+:", line):
                section_name = line.rstrip(":")
                if section_name not in result:
                    print(f"Warning: line {lineno} of config file contains an unknown section {section_name!r}")
                    result[section_name] = {}
                current_section = result[section_name]  # type: ignore
                continue

            match = re.fullmatch(r'(\w+) *= *(.*)', line)
            if match is None:
                print(f"Warning: line {lineno} of config file contains invalid syntax")
                continue

            key, value = match.groups()
            if key not in current_section:
                print(f"Warning: line {lineno} of config file contains an unknown key {key!r}")
            current_section[key] = json.loads(value)

    return result  # type: ignore


def save_config(config: Config, path: Path) -> None:
    with path.open("w", encoding="utf-8") as file:
        file.write(f"# Generated by {Path(__file__).name}\n")
        for key, value in config.items():
            if isinstance(value, dict):
                file.write(f"{key}:\n")
                for subkey, subvalue in value.items():
                    file.write(f'    {subkey} = {json.dumps(subvalue)}\n')
            else:
                file.write(f'{key} = {json.dumps(value)}\n')


def list_audio_devices() -> list[str]:
    output = subprocess.check_output(["aplay", "-L"], text=True)
    return [
        line.strip()
        for line in output.splitlines()
        if line.strip() and not line.startswith(" ")
    ]


def linear_map(in_start: float, in_end: float, out_start: float, out_end: float, value: float) -> float:
    slope = (out_end - out_start)/(in_end - in_start)
    return out_start + slope*(value - in_start)


def map_percentage_to_gain(calibration_values: list[float], percentage: float) -> float:
    assert 0 <= percentage <= 100
    assert len(calibration_values) == 11

    # Pick two known surrounding values (72% --> 70% and 80%).
    index = int(percentage / 10)
    if index == 10:
        # Special case for 100%, take 90%-100% range instead of 100%-110% range
        index = 9

    # Do linear interpolation (weighted average)
    return linear_map(
        # Comments show what happens when percentage is 72.
        10*index,  # 70
        10*(index + 1),  # 80
        calibration_values[index],  # volume at 70%
        calibration_values[index + 1],  # volume at 80%
        percentage,  # 72
    )


def construct_audio_data(config: Config, percents: dict[str, float]) -> bytes:
    assert percents.keys() == {"left", "right"}
    gains = [
        map_percentage_to_gain(config[channel]["calibration"], percents[channel])
        for channel in cast(list[Literal["left", "right"]], ["left", "right"])
    ]

    f = config["frequency"]
    duration = config["refresh_interval"]
    sample_rate = config["sample_rate"]

    audio_data = bytearray()
    for sample_num in range(round(duration * sample_rate)):
        for gain in gains:
            assert 0 <= gain <= 1
            t = sample_num / sample_rate
            sample = round(sin(2 * pi * f * t) * gain * 0x7fff)
            audio_data += sample.to_bytes(2, byteorder="little", signed=True)

    return bytes(audio_data)


class AudioPlayer:
    def __init__(self, config: Config) -> None:
        self.config = config
        self.thread: threading.Thread | None = None
        self.now_playing = {"left": 0.0, "right": 0.0}
        self.stopping: bool = False

    def get_command(self) -> list[str]:
        return [
            "aplay",
            "--format",
            "S16_LE",
            "--rate",
            str(self.config["sample_rate"]),
            "--channels",
            "2",
            "--device",
            self.config["audio_device"],
            "--buffer-time",
            str(round(self.config["refresh_interval"] * 1_000_000)),  # seconds to microseconds
        ]

    def start(self) -> None:
        if self.thread is not None:
            return  # already started

        self.stopping = False
        self.thread = threading.Thread(target=self._feed_audio_to_process)
        self.thread.start()

    def stop_everything(self) -> None:
        self.stopping = True
        if self.thread is not None:
            self.thread.join()

    def play(self, values: dict[str, float]) -> None:
        assert values.keys() == {"left", "right"}
        self.now_playing = values.copy()

    def play_single_channel(self, channel: str, value: float) -> None:
        self.play({"left": 0.0, "right": 0.0} | {channel: value})

    def play_random(self) -> None:
        self.play({"left": random.randint(0, 100), "right": random.randint(0, 100)})

    def _feed_audio_to_process(self) -> None:
        process = None
        command = None

        try:
            while not self.stopping:
                if process is None or command != self.get_command():
                    # Params changed --> start new aplay subprocess
                    if process is not None:
                        process.kill()

                    command = self.get_command()
                    process = subprocess.Popen(command, stdin=subprocess.PIPE, pipesize=1000)

                assert process is not None
                assert process.stdin is not None

                audio_data = construct_audio_data(self.config, self.now_playing)
                try:
                    process.stdin.write(audio_data)
                    process.stdin.flush()
                except OSError as e:
                    print("error running subprocess:", e, file=sys.stderr)
                    print("trying again after 1 second", file=sys.stderr)
                    process.kill()
                    process = None
                    time.sleep(1)

        finally:
            if process is not None:
                process.kill()
            self.now_running_command = None


class ConfigGUI:

    def __init__(self, container: ttk.Frame, player: AudioPlayer) -> None:
        self.player = player
        self.config = player.config
        self.last_saved_config = copy.deepcopy(self.config)
        self.user_wants_to_save = False

        self.create_device_selector(container).pack(padx=10, pady=20)

        meter_configurator_container = ttk.Frame(container)
        meter_configurator_container.pack(fill="both", expand=True)

        left = self.create_meter_configurator(meter_configurator_container, "left")
        right = self.create_meter_configurator(meter_configurator_container, "right")

        left.pack(side="left", fill="both", expand=True, padx=5, pady=10)
        right.pack(side="right", fill="both", expand=True, padx=5, pady=10)

        test_button = ttk.Button(
            container, text="Test with random values", command=player.play_random
        )
        test_button.pack(padx=5, pady=5)

        self.status_label = ttk.Label(container)
        self.status_label.pack()
        self.update_status_label()

    def create_device_selector(self, parent: ttk.Frame) -> ttk.Frame:
        container = ttk.Frame(parent)
        ttk.Label(container, text="Audio Device: ").pack(side="left")

        var = tkinter.StringVar()
        var.set(self.config["audio_device"])
        var.trace_add("write", lambda *junk: self.config.update({"audio_device": var.get()}))
        selector = ttk.Combobox(container, textvariable=var, values=list_audio_devices(), width=30)
        selector.pack(side="left")

        cast(Any, selector).i_dont_want_garbage_collection_to_eat_the_var = var
        return container

    def on_slider_moved(self, channel: Literal["left", "right"], percentage: int, new_value: str) -> None:
        gain = float(new_value) / 100 * MAX_GAIN
        self.config[channel]["calibration"][percentage // 10] = round(gain, 8)
        self.player.play_single_channel(channel, percentage)

    def create_meter_configurator(
        self, parent: ttk.Frame, channel: Literal["left", "right"],
    ) -> ttk.LabelFrame:
        channel_config = self.config[channel]

        container = ttk.LabelFrame(parent, text=f"Calibration for {channel_config['metric']} ({channel})")
        container.grid_columnconfigure(1, weight=1)

        for y, percentage in enumerate(range(0, 101, 10)):
            gain = self.config[channel]["calibration"][percentage // 10]
            label = ttk.Label(container, text=f"{percentage}%:")
            slider = ttk.Scale(
                container,
                from_=0,
                to=100,
                value=100 * gain / MAX_GAIN,
                command=partial(self.on_slider_moved, channel, percentage),
            )

            slider.bind(
                "<Enter>",
                (lambda event, p=percentage: self.player.play_single_channel(channel, p)),  # type: ignore
            )

            label.grid(row=y, column=0)
            slider.grid(row=y, column=1, sticky="we")

        return container

    def exit(self, *, save: bool) -> None:
        self.user_wants_to_save = save

        # TODO: accessing root window through the status label is a bit lol
        self.status_label.winfo_toplevel().destroy()

    def save_and_exit(self) -> None:
        self.exit(save=True)

    def maybe_save_and_exit(self) -> None:
        if self.config == self.last_saved_config:
            self.exit(save=False)
        else:
            result = messagebox.askyesnocancel("Mittari Configurator", "Do you want to save your changes?")
            if result is None:
                # cancel pressed
                return
            self.exit(save=bool(result))

    def format_status_of_one_meter(self, channel: Literal["left", "right"]) -> str:
        value = round(self.player.now_playing[channel])
        metric = self.config[channel]["metric"]  # e.g. "CPU"
        return f"{value}% {metric}"

    def update_status_label(self) -> None:
        self.status_label.after(50, self.update_status_label)

        left_status = self.format_status_of_one_meter('left')
        right_status = self.format_status_of_one_meter('right')
        self.status_label.config(text=f"Meters should be showing {left_status} and {right_status}.")


def main() -> None:
    if len(sys.argv) != 2 or sys.argv[1].startswith('-'):
        print(f"Usage: {sys.argv[0]} your-mittari-config-file.conf", file=sys.stderr)
        sys.exit(2)

    config_path = Path(sys.argv[1])
    try:
        config = load_config(config_path)
    except FileNotFoundError:
        print(f'File "{config_path}" does not exist, creating it now.')
        config = copy.deepcopy(DEFAULT_CONFIG)
        save_config(config, config_path)

    player = AudioPlayer(config)
    player.start()
    try:
        root = tkinter.Tk()
        root.title(f"Mittari Configurator: {config_path.name}")
        root.minsize(700, 500)

        big_frame = ttk.Frame(root)
        big_frame.pack(fill="both", expand=True)

        gui = ConfigGUI(big_frame, player)

        ttk.Separator(root).pack(fill="x")

        button_frame = ttk.Frame(root)
        button_frame.pack(fill="x")

        ok_button = ttk.Button(button_frame, text="Save and Exit", command=gui.save_and_exit)
        cancel_button = ttk.Button(button_frame, text="Cancel", command=root.destroy)

        ok_button.pack(side="right", padx=5, pady=5)
        cancel_button.pack(side="right", padx=5, pady=5)

        root.protocol("WM_DELETE_WINDOW", gui.maybe_save_and_exit)
        root.mainloop()

        if gui.user_wants_to_save:
            save_config(config, config_path)

    finally:
        player.stop_everything()


if __name__ == "__main__":
    main()
